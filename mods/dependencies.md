---
description: Как установить зависимости для модов Geode
---

# Зависимости

Geode предоставляет инструменты, позволяющие модам зависеть от других модов, что упрощает переиспользование кода.

Обратите внимание, что Geode **управляет только теми зависимостями, которые являются модами**. Обычные зависимости C++, такие как библиотека для парсинга JSON, библиотека ZIP или какие-нибудь сетевые утилиты, **должны быть просто установлены, как и в любом другом проекте на C++**. Используйте CPM, Git-подмодули, копируйте код в свой проект, в общем, как вам удобнее. Если библиотека динамическая, подключите `.dll` к своему моду через ключ `files` в `resources`.

Однако, иногда возникает необходимость использовать код, который нельзя подключить как обычную библиотеку; например, **custom keybinds**. Geode не предоставляет никаких готовых иструментов для настройки пользовательских клавиш, поэтому вам придется использовать библиотеку. Однако было бы не очень разумно, если бы каждый мод поставлял свои собственные несовместимые средства для работы с привязками клавиш. Вместо этого, должен быть один мод, который просто добавляет эту функциональность, а затем другие моды могут зависеть от него и вызывать его функции для работы с пользовательскими клавишами.

## Как работают моды-зависимости

Моды-зависимости по своей сути аналогичны обычным модам, за исключением того, что они **включают свои заголовочные файлы и файлы для линковки в свой .geode пакет**. Обычно заголовочные файлы находятся в папке `include` внутри пакета, но могут располагаться и в любом другом месте. Файл для линковки представляет собой `mod.id.lib` на Windows или бинарный файл мода в корне пакета на прочих платформах.

В остальном, моды-зависимости ничем не отличаются от обычных модов; они могут устанавливать хуки, патчи, добавлять функции в игру и публиковаться в каталоге модов. Однако, **моды-зависимости должны сводить функциональность, которую они добавляют, к минимуму**, и быть сфокусированными на конкретных функциях, которые они призваны добавлять. Например, мод-зависимость для пользовательских горячих клавиш должна добавлять только необходимое для работы с горячими клавишами; она не должна добавлять кучу других функций, таких как добавление новых иконок или настройка меню.

Если зависимость является обязательной, то она **линкуется**, что означает необходимость ее наличия для запуска мода, от неё зависящего. Однако, с учетом того, что иногда требуется использовать зависимость только в случае ее загрузки, **существует возможность пометить зависимость как необязательную**. В этом случае она не линкуется, а значит, прямое использование ее функций становится невозможным; вместо этого, необходимо применять функции Geode, предназначенные для работы с необязательными зависимостями. Дополнительные сведения можно найти в разделе [Необязательные зависимости](#optional-dependencies).

## Добавление зависимостей

Зависимости можно включить в ваш мод, просто добавив их в ключ `dependencies` в [mod.json](/mods/configuring.md):

```json
{
    "geode": "v1.0.0",
    "id": "my.example-mod",
    "name": "My example mod",
    "developer": "Me",
    "version": "v1.0.0",
    "dependencies": [
        {
            "id": "someone-elses.mod",
            "version": ">=v1.2.5",
            "importance": "required"
        }
    ]
}
```

Зависимости имеют два обязательных свойства: ID зависимости и версию, от которой зависит мод. Кроме того, у зависимости может быть [важность](#importance), которая указывает, является ли зависимость обязательной или нет.

Поле `версии` зависимости может быть записано как `>=версия`, `=версия`, или `<=версия`. Сравнения работают как и ожидается, с дополнением, что если мажорные версии отличаются, сравнение всегда ложно. Это означает, что если вы зависите от версии `>=1.2.5` мода, версия `v1.8.0` будет считаться приемлемой, но `v2.0.0` не будет. По этой причине, [если вы делаете мод, от которого зависят другие, вам следует строго придерживаться образца semver](https://semver.org).

Как только вы добавили зависимость в свой `mod.json`, если у вас есть [Geode CLI v1.4.0 или выше](/geode/installcli), его заголовки автоматически добавляются в ваш проект. Если у вас установлен мод, будут использоваться заголовки из установленной версии. Если у вас нет установленного мода, Geode установит его из индекса модов. Добавленные файлы зависимостей для вашего проекта можно найти в `build/geode-deps/<dep.id>`. Geode автоматически добавляет `build/geode-deps` в путь включения вашего проекта и линкует любые бинарные файлы, найденные в зависимостях, что означает, что вам, скорее всего, не нужно ничего настраивать.

## Пример

Мод `hjfod.gmd-api` содержит инструменты для работы с [.GMD файлами](https://fileinfo.com/extension/gmd). Вы можете добавить его в свой мод, добавив следующее в `mod.json`.:

```json
{
    "dependencies": [
        {
            "id": "hjfod.gmd-api",
            "version": ">=v1.0.0"
        }
    ]
}
```

Теперь, если вы перенастроите свой CMake (или, если вы используете CMake Tools в VS Code, он должен перенастроиться автоматически), Geode автоматически найдет hjfod.gmd-api в ваших установленных модах. Если мода нет в индексе, Geode установит его для вас.

```cpp
#include <hjfod.gmd-api/include/GMD.hpp>
// действия с gmd-api
```

Теперь, если вы скомпилируете и протестируете свой мод, все должно уже заработать.

## Важность

> Возможные значения:
> - `required` (по умолчанию) - Зависимость должна быть установлена, чтобы этот мод работал.
> - `recommended` - Зависимость не является обязательной, но рекомендуется и будет загружена по умолчанию.
> - `suggested` - Зависимость не является обязательной и не будет загружена по умолчанию.

Если зависимость **не является обязательной**, она не подключается, что, в свою очередь, означает, что вы не можете использовать ни одну из ее экспортированных функций. В таких случаях зависимость должна предоставлять способы динамического вызова своих функций через Geode, например, через события.

### События

Ключевой системой, которую Geode предоставляет для необязательного взаимодействия между модами, являются события. Например, мод, который добавляет поддержку перетаскивания файлов на окно GD, может определить событие перетаскивания, которое другие моды могут затем отслеживать.

Обычно, однако, события определяются в коде таким образом, что требуется их подключение путем наследования от класса `Event`. Чтобы этого избежать, моды, которые хотят поддерживать необязательное использование, должны также предоставлять события, которые являются специализациями класса `DispatchEvent`:

```cpp
using DragDropEvent = geode::DispatchEvent<ghc::filesystem::path>;
using DragDropFilter = geode::DispatchFilter<ghc::filesystem::path>;

// Отправка событий в коде
DragDropEvent("geode.drag-drop/default", "path/to/file").post();
```

У всех `DispatchEvent` есть связанный ID, который является специфичным для каждой специализации `DispatchEvent`. Это можно использовать для различения событий; например, API перетаскивания может использовать это, чтобы позволить зависимостям определять, какие типы файлов они отслеживают.

Моды, которые используют зависимость, теперь могут отслеживать события перетаскивания:

```cpp
$execute {
    new EventListener(+[](ghc::filesystem::path const& path) {
        log::info("File dropped: {}", path);
        return ListenerResult::Propagate;
    }, DragDropFilter("geode.drag-drop/default"));
};
```

Пример использования диспетчерских событий на практике [можно найти в MouseAPI](https://github.com/geode-sdk/MouseAPI/blob/main/src/test.cpp#L54-L94).

### Атрибуты

One way for mods to communicate with optional dependencies is through **node attributes**, which may contain any data. These are like the `setUserData` and `setUserObject` functions native to `CCNode`s, except that attributes have a string key associated with them. For example, a mod that adds scrollbars to layers might use the following check to see if a scrollbar should be added to a layer:

Еще один способ для модов взаимодействовать с необязательными зависимостями - это **атрибуты узлов**, которые могут содержать любые данные. Они похожи на функции `setUserData` и `setUserObject`, встроенные в `CCNode`, за исключением того, что атрибуты имеют связанный с ними строковый ключ. Например, мод, добавляющий полосы прокрутки к слоям, может использовать следующую проверку, чтобы узнать, нужно ли добавлять полосу прокрутки к слою:

```cpp
if (layer->getAttribute<bool>("hjfod.cool-scrollbars/enable")) {
    // добавить полосу прокрутки
}
```

Другие моды могут устанавливать этот атрибут на своих слоях с помощью функции `CCNode::setAttribute`.

Также моды могут добавить прослушиватель событий для отслеживания добавления/изменения атрибутов:

```cpp
$execute {
    new EventListener<AttributeSetFilter>(
        +[](AttributeSetEvent* event) {
            addScrollbar(event->node);
        },
        AttributeSetFilter("hjfod.cool-scrollbars/enable")
    );
}
```
